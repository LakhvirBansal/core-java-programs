package amazon;

import java.io.*;
import java.util.*;

public class FindVulnerabilityFactor {

    public static void main(String[] args) throws IOException {
        int n = 5;
        List<Integer> key = Arrays.asList(2,2,4,9,6);
        int maxChange = 1;
        System.out.println(findVulnerabilityFactor(key, maxChange));
    }

    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = key.get(i);

        // Build log2
        int[] log2 = new int[n + 1];
        for (int i = 2; i <= n; i++) log2[i] = log2[i >> 1] + 1;

        // Build sparse table
        int K = log2[n] + 1;
        int[][] st = new int[K][n];
        for (int i = 0; i < n; i++) st[0][i] = a[i];
        for (int k = 1; k < K; k++) {
            int len = 1 << k;
            for (int i = 0; i + len <= n; i++) {
                st[k][i] = gcd(st[k - 1][i], st[k - 1][i + (len >> 1)]);
            }
        }

        // Binary search for minimal X
        int lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + ((hi - lo) >>> 1);
            if (isValid(mid + 1, a, st, log2, maxChange)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }

        return lo;
    }

    private static boolean isValid(int windowSize, int[] a, int[][] st, int[] log2, int maxChange) {
        int n = a.length;
        int used = 0;
        int i = 0;

        while (i + windowSize - 1 < n) {
            int j = i + windowSize - 1;
            int g = rangeGcd(i, j, st, log2);
            if (g == 1) {
                i++;
            } else {
                used++;
                if (used > maxChange) return false;
                i = j + 1;  // skip ahead
            }
        }

        return true;
    }

    private static int rangeGcd(int l, int r, int[][] st, int[] log2) {
        int len = r - l + 1;
        int k = log2[len];
        return gcd(st[k][l], st[k][r - (1 << k) + 1]);
    }

    private static int gcd(int a, int b) {
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }

    static class FastReader {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
 }

//    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
//        int n = key.size();
//        int[] a = new int[n];
//        for (int i = 0; i < n; i++) a[i] = key.get(i);
//
//        // Build log2
//        int[] log2 = new int[n + 1];
//        for (int i = 2; i <= n; i++) log2[i] = log2[i >> 1] + 1;
//
//        // Build sparse table
//        int K = log2[n] + 1;
//        int[][] st = new int[K][n];
//        for (int i = 0; i < n; i++) st[0][i] = a[i];
//        for (int k = 1; k < K; k++) {
//            int len = 1 << k;
//            for (int i = 0; i + len <= n; i++) {
//                st[k][i] = gcd(st[k - 1][i], st[k - 1][i + (len >> 1)]);
//            }
//        }
//
//        // Binary search for minimal X
//        int lo = 0, hi = n;
//        while (lo < hi) {
//            int mid = lo + ((hi - lo) >>> 1);
//            if (isValid(mid + 1, a, st, log2, maxChange)) {
//                hi = mid;
//            } else {
//                lo = mid + 1;
//            }
//        }
//
//        return lo;
//    }
//
//    private static boolean isValid(int windowSize, int[] a, int[][] st, int[] log2, int maxChange) {
//        int n = a.length;
//        int used = 0;
//        int i = 0;
//
//        while (i + windowSize - 1 < n) {
//            int j = i + windowSize - 1;
//            int g = rangeGcd(i, j, st, log2);
//            if (g == 1) {
//                i++;
//            } else {
//                used++;
//                if (used > maxChange) return false;
//                i = j + 1;  // skip ahead
//            }
//        }
//
//        return true;
//    }
//
//    private static int rangeGcd(int l, int r, int[][] st, int[] log2) {
//        int len = r - l + 1;
//        int k = log2[len];
//        return gcd(st[k][l], st[k][r - (1 << k) + 1]);
//    }
//
//    private static int gcd(int a, int b) {
//        while (b != 0) {
//            int tmp = b;
//            b = a % b;
//            a = tmp;
//        }
//        return a;
//    }
//
//    static class FastReader {
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
//        StringTokenizer st;
//
//        String next() throws IOException {
//            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
//            return st.nextToken();
//        }
//
//        int nextInt() throws IOException {
//            return Integer.parseInt(next());
//        }
//    }


    // another approach

    /*
    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader();
        int n = in.nextInt();
        // read exactly n integers, whether they come on one line or multiple
        List<Integer> key = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            key.add(in.nextInt());
        }
        int maxChange = in.nextInt();

        int answer = findVulnerabilityFactor(key, maxChange);
        System.out.println(answer);
    }

    static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();
        // copy into primitive array for speed
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = key.get(i);

        // 1) build log2 table
        int[] log2 = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            log2[i] = log2[i >> 1] + 1;
        }

        // 2) build sparse table st[k][i] = gcd of a[i..i+2^k-1]
        int K = log2[n] + 1;
        int[][] st = new int[K][n];
        for (int i = 0; i < n; i++) {
            st[0][i] = a[i];
        }
        for (int k = 1; k < K; k++) {
            int len = 1 << k;
            for (int i = 0; i + len <= n; i++) {
                st[k][i] = gcd(st[k - 1][i], st[k - 1][i + (len >> 1)]);
            }
        }

        // 3) binary‐search minimal X in [0..n] so that vulnerability ≤ X
        int lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + ((hi - lo) >>> 1);
            if (can(mid, a, st, log2, maxChange)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }

    // check if after ≤ maxChange mods we can ensure NO subarray of length (X+1) has gcd>1
    private static boolean can(int X, int[] a, int[][] st, int[] log2, int maxChange) {
        int n = a.length;
        int window = X + 1;
        int used = 0, nextCover = -1;

        for (int i = 0; i + window - 1 < n; i++) {
            if (i <= nextCover) continue;      // already “broken” by a previous mod
            if (rangeGcd(i, i + window - 1, st, log2) > 1) {
                // place a modification at the window’s right end
                if (++used > maxChange) return false;
                nextCover = i + window - 1;
            }
        }
        return true;
    }

    // O(1) GCD on [l..r] via sparse table
    private static int rangeGcd(int l, int r, int[][] st, int[] log2) {
        int len = r - l + 1;
        int k = log2[len];
        int left = st[k][l];
        int right = st[k][r - (1 << k) + 1];
        return gcd(left, right);
    }

    // fast iterative Euclid
    private static int gcd(int x, int y) {
        while (y != 0) {
            int t = y;
            y = x % y;
            x = t;
        }
        return x;
    }
     */
}