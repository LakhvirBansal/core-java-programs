package amazon;
import java.io.*;
import java.util.*;
public class findVulnerabilityFactorLatest {

    public static void main(String[] args) throws IOException {
        int n = 5;
        List<Integer> key = Arrays.asList(2,2,4,9,6);
        int maxChange = 1;
        System.out.println(findVulnerabilityFactor(key, maxChange));
    }

    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = key.get(i);

        // Build log2
        int[] log2 = new int[n + 1];
        for (int i = 2; i <= n; i++) log2[i] = log2[i >> 1] + 1;

        // Build sparse table
        int K = log2[n] + 1;
        int[][] st = new int[K][n];
        for (int i = 0; i < n; i++) st[0][i] = a[i];
        for (int k = 1; k < K; k++) {
            int len = 1 << k;
            for (int i = 0; i + len <= n; i++) {
                st[k][i] = gcd(st[k - 1][i], st[k - 1][i + (len >> 1)]);
            }
        }

        // Binary search for minimal X
        int lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + ((hi - lo) >>> 1);
            if (isValid(mid + 1, a, st, log2, maxChange)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }

        return lo;
    }

    private static boolean isValid(int windowSize, int[] a, int[][] st, int[] log2, int maxChange) {
        int n = a.length;
        int used = 0;
        int i = 0;

        while (i + windowSize - 1 < n) {
            int j = i + windowSize - 1;
            int g = rangeGcd(i, j, st, log2);
            if (g == 1) {
                i++;
            } else {
                used++;
                if (used > maxChange) return false;
                i = j + 1;  // skip ahead
            }
        }

        return true;
    }

    private static int rangeGcd(int l, int r, int[][] st, int[] log2) {
        int len = r - l + 1;
        int k = log2[len];
        return gcd(st[k][l], st[k][r - (1 << k) + 1]);
    }

    private static int gcd(int a, int b) {
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }

    static class FastReader {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
    }
}
